前情回顾

1. 自定义进程类

 继承 Process--》 重写__init__-->调用父类init--》重写run

2. 进程池 （大量频繁产生进程应对源源不断的事件）

   Pool()
   apply_async()
   close()
   join()

3. 消息队列  （进程间通信   IPC）

   Queue()
   q.get()
   q.put()

4. 聊天室

* 逻辑思考流程
* while--> if  接收请求分情况讨论
* 当客户端请求类型有多种时 设计简单的通信协议 进行区分

1. 需求分析
    * 有人进入聊天室需要输入姓名，姓名不能重复
    * 有人进入聊天室时，其他人会收到通知：xxx 进入了聊天室
    * 一个人发消息，其他人会收到：xxx ： xxxxxxxxxxx
    * 有人退出聊天室，则其他人也会收到通知:xxx退出了聊天室

2. 技术点分析

   存储 ：  用户名  用户地址
           {name:address}  [(name,address)...]

   网络 :  udp通信

   收发消息 ： 转发  建立进程  一个进程负责发送一个接收


3. 功能划分和模块设计（封装设计）

   封装： 函数封装

   模型结构
   进入聊天室
   聊天
   退出聊天室

4. 网络协议设计

              请求的类型      数据参量
  进入聊天室     LOGIN         name
  聊天          CHAT         name content
  退出          EXIT         ........


5. 功能拆分实践

   模型结构
       服务端： 1. 创建udp循环模型
               2. 循环接收各个客户端的各种请求
               3. 根据请求调用模块执行具体功能

       客户端： 1. 创建udp套接字

   进入聊天室
       客户端： 1. 输入姓名
               2. 发送姓名
               3. 接收结果
               4. 进入聊天室/ 回到第一步

       服务端： 1. 接收姓名
               2. 判断用户是否已经存在
               3. 根据判断发送结果
               4. Yes 通知其他人 将用户信息存储
                  No  结束

   聊天
      客户端：　创建子进程
      　　　　　子进程循环接收消息打印
      　　　　　父进程循环发送消息

      服务端：　接收请求　解析
      　　　　　转发给其他人
      　　　　　　　

   退出聊天室


6. 优化重构完善

cookie :  set get方法使用
class Person:
    def __init__(self,age):
        self.__age = age

    def setAge(self,age):
        if age < 0:
            self.__age = 0
        else:
            self.__age = age

    def getAge(self):
        return self.__age

han = Person(18)
han.setAge(3)
print(han.getAge())


练习1： 模拟一个售票系统
现在有500张票  T1--T500  将票放入列表
创建10个线程 记为 w1 -- w10 模拟10个买票机器
10个线程同时买票知道所有票卖完为止
票按照顺序卖出，每张票出票时间为0.1秒

打印 w5----T203 表示票卖出


练习2： 用两个分支线程分别打印 A-Z 和 1-52
两个线程启动后 打印顺序为  12A34B56C....5152Z

提示： 一个程序中不一定用一个锁


作业： 1. 聊天室  结构和思路 梳理
      2. 线程创建
      3. 使用多线程求100000以内质数之和，验证时间
         4线程  10线程








